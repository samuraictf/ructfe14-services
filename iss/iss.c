/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2014 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/socket.h>
#include <stdint.h>
#include <signal.h>
#include <errno.h>
#include <netinet/in.h>
#include <poll.h>
#include <fcntl.h>

//-------------------------------------------------------------------------
// Data declarations

FILE *file; // idb
char  **root; // idb

//----- (08048EF0) --------------------------------------------------------
void make_non_blocking(int a1)
{
  int v1; // eax@1
  int result; // eax@1

  v1 = fcntl(a1, F_GETFL);
  result = fcntl(a1, F_SETFL, v1 | O_NONBLOCK);
  if ( result < 0 )
  {
    perror("fcntl() on set O_NONBLOCK failed");
    exit(-1);
  }
}

//----- (08049030) --------------------------------------------------------
int check_alphabet(const char *a1)
{
  size_t i; // [sp+4h] [bp-10h]@3
  size_t v3; // [sp+8h] [bp-Ch]@1
  signed int v4; // [sp+10h] [bp-4h]@2

  v3 = strlen(a1);
  if ( v3 )
  {
    for ( i = 0; i < v3; ++i )
    {
      if ( a1[i] != 'A' && a1[i] != 'T' && a1[i] != 'G' && a1[i] != 'C' )
        return 0;
    }
    v4 = 1;
  }
  else
  {
    v4 = 0;
  }
  return v4;
}

//----- (08049110) --------------------------------------------------------
int try_match_rec(char **a1, char * a2, signed int a3, char *a4)
{
  int v4; // eax@9
  int v5; // eax@18
  int v6; // eax@27
  int v7; // eax@36
  int v9; // [sp+13h] [bp-51h]@42
  char * v10; // [sp+18h] [bp-4Ch]@35
  char ** v11; // [sp+1Ch] [bp-48h]@35
  char * v12; // [sp+24h] [bp-40h]@26
  char** v13; // [sp+28h] [bp-3Ch]@26
  char * v14; // [sp+30h] [bp-34h]@17
  char **v15; // [sp+34h] [bp-30h]@17
  char *src; // [sp+3Ch] [bp-28h]@8
  char **dest; // [sp+40h] [bp-24h]@8
  int v18; // [sp+58h] [bp-Ch]@2

  if ( a3 <= 2 )
  {
    if ( *a2 || !a1[4] )
    {
      if ( a1[0] )
      {
        *a4 = 'A';
        if ( *a2 )
        {
          dest = (char**)a1[0];
          src = a2 + 1;
          v4 = *a2 == 'A' ? try_match_rec(dest, src, a3, a4 + 1) : try_match_rec(dest, src, a3 + 1, a4 + 1);
          if ( v4 )
            return 1;
        }
        if ( try_match_rec((char**)a1[0], a2, a3 + 1, a4 + 1) )
          return 1;
      }
      if ( a1[1] )
      {
        *a4 = 'T';
        if ( *a2 )
        {
          v15 = (char**)a1[1];
          v14 = a2 + 1;
          v5 = *a2 == 'T' ? try_match_rec(v15, v14, a3, a4 + 1) : try_match_rec(v15, v14, a3 + 1, a4 + 1);
          if ( v5 )
            return 1;
        }
        if ( try_match_rec((char**)a1[1], a2, a3 + 1, a4 + 1) )
          return 1;
      }
      if ( a1[2] )
      {
        *a4 = 'G';
        if ( *a2 )
        {
          v13 = (char**)a1[2];
          v12 = a2 + 1;
          v6 = *a2 == 'G' ? try_match_rec(v13, v12, a3, a4 + 1) : try_match_rec(v13, v12, a3 + 1, a4 + 1);
          if ( v6 )
            return 1;
        }
        if ( try_match_rec((char**)a1[2], a2, a3 + 1, a4 + 1) )
          return 1;
      }
      if ( a1[3] )
      {
        *a4 = 'C';
        if ( *a2 )
        {
          v11 = (char**)a1[3];
          v10 = a2 + 1;
          v7 = *a2 == 'C' ? try_match_rec(v11, v10, a3, a4 + 1) : try_match_rec(v11, v10, a3 + 1, a4 + 1);
          if ( v7 )
            return 1;
        }
        if ( try_match_rec((char**)a1[3], a2, a3 + 1, a4 + 1) )
          return 1;
      }
      *a4 = 0;
      v9 = 0;
      if ( *a2 )
        v9 = try_match_rec(a1, a2 + 1, a3 + 1, a4) != 0;
      v18 = v9;
    }
    else
    {
      *a4 = ' ';
      v18 = 1;
      strcpy(a4 + 1, a1[4]);
    }
  }
  else
  {
    v18 = 0;
  }
  return v18;
}

//----- (080495B0) --------------------------------------------------------
signed int try_match(char * a1, char * a2)
{
  return try_match_rec(root, a1, 0, a2);
}

//----- (08049600) --------------------------------------------------------
char *try_add_pattern(char *a1, char *a2)
{
  size_t i; // [sp+44h] [bp-20h]@1
  char **v4; // [sp+48h] [bp-1Ch]@1
  size_t v5; // [sp+4Ch] [bp-18h]@1
  size_t v6; // [sp+50h] [bp-14h]@1
  char *v7; // [sp+5Ch] [bp-8h]@20

  v6 = strlen(a1);
  v5 = strlen(a2);
  v4 = root;
  for ( i = 0; i < v6; ++i )
  {
    switch ( a1[i] )
    {
      case 'A':
        if ( !v4[0] )
        {
          v4[0] = malloc(20);
          memset(v4[0], 0, 0x14u);
        }
        v4 = (char**)v4[0];
        break;
      case 'T':
        if ( !v4[1] )
        {
          v4[1] = malloc(20);
          memset(v4[1], 0, 0x14u);
        }
        v4 = (char**)v4[1];
        break;
      case 'G':
        if ( !v4[2] )
        {
          v4[2] = malloc(20);
          memset(v4[2], 0, 0x14u);
        }
        v4 = (char**)v4[2];
        break;
      default:
        if ( !v4[3] )
        {
          v4[3] = malloc(20);
          memset(v4[3], 0, 0x14u);
        }
        v4 = (char**)v4[3];
        break;
    }
  }
  if ( v4[4] )
  {
    v7 = v4[4];
  }
  else
  {
    v4[4] = malloc(v5 + 1);
    memset(v4[4], 0, v5 + 1);
    v7 = a2;
    strcpy(v4[4], a2);
  }
  return v7;
}

//----- (080498C0) --------------------------------------------------------
int init_state(FILE *a1)
{
  char *v2; // [sp+24h] [bp-18h]@4
  int v3; // [sp+28h] [bp-14h]@1
  size_t v4; // [sp+30h] [bp-Ch]@1
  char *v5; // [sp+34h] [bp-8h]@1

  v5 = malloc(128);
  v4 = 0;
  v3 = 0;
  while ( fread(v4 + v5, 1u, 1u, a1) > 0 )
  {
    if ( v5[v4] == '\n' )
    {
      v5[v4] = 0;
      v2 = memchr(v5, ' ', v4);
      if ( !v2 )
      {
        fprintf(stderr, "Corrupted state!");
        exit(-1);
      }
      *v2 = 0;
      v4 = 0;
      ++v3;
      try_add_pattern(v5, v2 + 1);
    }
    else
    {
      ++v4;
    }
  }
  return v3;
}

//----- (08049A00) --------------------------------------------------------
void  run(int port)
{
  int v2; // eax@4
  int v4; // ecx@4
  int v5; // edx@23
  int v6; // edx@37
  char *v7; // esi@39
  size_t v8; // ecx@39
  size_t v11; // eax@68
  size_t v13; // eax@77
  int v14; // eax@82
  char *v15; // [sp+0h] [bp-24254h]@82
  int v16; // [sp+4h] [bp-24250h]@4
  int v20; // [sp+1Ch] [bp-24238h]@82
  void *v25; // [sp+30h] [bp-24224h]@77
  int v35; // [sp+58h] [bp-241FCh]@68
  void *v36; // [sp+5Ch] [bp-241F8h]@68
  int v37; // [sp+60h] [bp-241F4h]@66
  int v38; // [sp+64h] [bp-241F0h]@66
  char *v42; // [sp+74h] [bp-241E0h]@62
  int v43; // [sp+78h] [bp-241DCh]@61
  int v47; // [sp+88h] [bp-241CCh]@58
  void *buf; // [sp+98h] [bp-241BCh]@48
  int v52; // [sp+9Ch] [bp-241B8h]@39
  int v53; // [sp+A0h] [bp-241B4h]@37
  int v54; // [sp+A4h] [bp-241B0h]@35
  int v55; // [sp+A8h] [bp-241ACh]@23
  int v56; // [sp+ACh] [bp-241A8h]@20
  void *v57; // [sp+B0h] [bp-241A4h]@19
  void *v58; // [sp+B4h] [bp-241A0h]@19
  int v59; // [sp+B8h] [bp-2419Ch]@19
  int v60; // [sp+BCh] [bp-24198h]@19
  int v61; // [sp+C0h] [bp-24194h]@19
  int v62; // [sp+C4h] [bp-24190h]@19
  void *v63; // [sp+C8h] [bp-2418Ch]@19
  int v64; // [sp+CCh] [bp-24188h]@19
  int v65; // [sp+D0h] [bp-24184h]@18
  int v67; // [sp+D8h] [bp-2417Ch]@15
  int v71; // [sp+E8h] [bp-2416Ch]@12
  int v74; // [sp+F4h] [bp-24160h]@9
  int v78; // [sp+104h] [bp-24150h]@7
  int v79; // [sp+108h] [bp-2414Ch]@7
  int v80; // [sp+10Ch] [bp-24148h]@7
  int v81; // [sp+110h] [bp-24144h]@5
  int v84; // [sp+11Ch] [bp-24138h]@4
  int v85; // [sp+120h] [bp-24134h]@3
  const char *v91; // [sp+138h] [bp-2411Ch]@72
  char *src; // [sp+13Ch] [bp-24118h]@60
  int v93; // [sp+140h] [bp-24114h]@56
  char *v94; // [sp+144h] [bp-24110h]@54
  char *v95; // [sp+148h] [bp-2410Ch]@46
  socklen_t addr_len; // [sp+14Ch] [bp-24108h]@31
  struct sockaddr_in ca; // [sp+150h] [bp-24104h]@31
  int v98; // [sp+160h] [bp-240F4h]@29
  unsigned int v99; // [sp+164h] [bp-240F0h]@23
  char *v100; // [sp+168h] [bp-240ECh]@19
  int j; // [sp+16Ch] [bp-240E8h]@88
  int i; // [sp+170h] [bp-240E4h]@23
  nfds_t v103; // [sp+174h] [bp-240E0h]@1
  nfds_t nfds; // [sp+178h] [bp-240DCh]@1
  char *dest; // [sp+17Ch] [bp-240D8h]@39
  int v106[1025]; // [sp+180h] [bp-240D4h]@19
  int v107[1025]; // [sp+1184h] [bp-230D0h]@19
  char v108[131200]; // [sp+2188h] [bp-220CCh]@19
  struct pollfd fds[1025]; // [sp+22208h] [bp-204Ch]@19
  struct sockaddr_in addr; // [sp+24210h] [bp-44h]@13
  int v112; // [sp+24224h] [bp-30h]@25
  int v113; // [sp+24228h] [bp-2Ch]@1
  int client; // [sp+2422Ch] [bp-28h]@1
  int fd; // [sp+24230h] [bp-24h]@1
  int optval; // [sp+24234h] [bp-20h]@1
  int v117; // [sp+24238h] [bp-1Ch]@10
  size_t size; // [sp+2423Ch] [bp-18h]@51
  int v119; // [sp+24240h] [bp-14h]@1

  v119 = port;
  optval = 1;
  fd = -1;
  client = -1;
  v113 = 0;
  nfds = 1;
  v103 = 0;
  root = (void *)malloc(20);
  memset(root, 0, 0x14u);
  file = fopen("state", "a+");
  if ( !file )
  {
    perror("can't open state file for writing");
    exit(-1);
  }
  v84 = 0;
  fseek(file, SEEK_SET, 0);
  v2 = init_state(file);
  printf("Loaded %d lines from state file\n", v2);
  make_non_blocking(fileno(file));
  v78 = setvbuf(file, 0, 2, 0);
  fd = socket(AF_INET, SOCK_STREAM, 0);
  if ( fd < 0 )
  {
    perror("socket() failed");
    exit(-1);
  }
  v117 = setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval));
  if ( v117 < 0 )
  {
    perror("setsockopt() failed");
    exit(-1);
  }
  make_non_blocking(fd);
  memset(&addr, 0, sizeof(addr));
  addr.sin_family = AF_INET;
  addr.sin_port = htons(port);
  if ( bind(fd, (struct sockaddr*)&addr, sizeof(addr)) < 0 )
  {
    perror("bind() failed");
    exit(-1);
  }
  if ( listen(fd, 1024) < 0 )
  {
    perror("listen() failed");
    exit(-1);
  }
  v64 = 128;
  v63 = v108;
  v62 = 8200;
  v61 = 131200;
  v60 = 0;
  v59 = 4100;
  v58 = v106;
  v57 = v107;
  memset(fds, 0, sizeof(fds));
  fds[0].fd = fd;
  fds[0].events = POLLIN;
  memset(v108, 0, 0x20080u);
  memset(v107, 0, 0x1004u);
  memset(v106, 0, 0x1004u);
  v100 = (char *)malloc(128);
  do
  {
    while ( 1 )
    {
      v56 = -1;
      v117 = poll(fds, nfds, -1);
      if ( v117 < 0 )
        break;
      v99 = time(NULL);
      v103 = nfds;
      i = 0;
      v55 = v5;
      while ( i < (signed int)v103 )
      {
        v112 = 0;
        if ( fds[i].fd != fd && v106[i] && v106[i] + 30 < v99 )
          v112 = 1;
        v98 = fds[i].fd;
        if ( fds[i].revents )
        {
          if ( v98 == fd )
          {
            while ( 1 )
            {
              addr_len = sizeof(ca);
              client = accept(fd, (struct sockaddr*)&ca, &addr_len);
              if ( client < 0 )
                break;
              make_non_blocking(client);
              fds[nfds].fd = client;
              fds[nfds].events = POLLIN;
              v106[nfds++] = time(NULL);
              v53 = v6;
              if ( client == -1 )
                goto LABEL_81;
            }
            if ( errno != EAGAIN)
            {
              perror("accept() failed");
              exit(-1);
            }
          }
          else
          {
            while ( 1 )
            {
              dest = &v108[128 * i];
              v7 = &dest[v107[i]];
              v8 = 128 - v107[i];
              v52 = 0;
              v117 = recv(v98, v7, v8, 0);
              if ( v117 < 0 )
                break;
              if ( !v117 )
              {
                v112 = 1;
                goto LABEL_81;
              }
              v107[i] += v117;
              v95 = (char*)memchr(dest, '\n', v107[i]);
              if ( v95 )
              {
                size = v95 - dest;
                if ( size > 0 && dest[size - 1] == '\r' )
                  --size;
                dest[size] = 0;
                v94 = (char *)memchr(dest, ' ', size);
                if ( v94 )
                {
                  *v94++ = 0;
                  if ( check_alphabet(dest) )
                  {
                    v91 = try_add_pattern(dest, v94);
                    v94[-1] = ' ';
                    if ( v91 == v94 )
                    {
                      fwrite(dest, size, 1u, file);
                      fwrite("\n", 1u, 1u, file);
                    }
                    sprintf(v100, "%s\n", v91);
                    v117 = send(v98, v100, strlen(v100), 0);
                    if ( v117 < 0 )
                    {
                      perror("send() failed");
                      v112 = 1;
                      goto LABEL_81;
                    }
                  }
                  else
                  {
                    v25 = "Invalid Virus Pattern string, must be in <DNA-sequence><space><Comment> format\n";
                    v117 = send(v98, v25, strlen(v25), 0);
                    if ( v117 < 0 )
                    {
                      perror("send() failed");
                      v112 = 1;
                      goto LABEL_81;
                    }
                  }
                }
                else if ( check_alphabet(dest) )
                {
                  v93 = fork();
                  if ( v93 == -1 )
                  {
                    perror("fork()");
                    exit(-1);
                  }
                  if ( !v93 )
                  {
                    src = (char *)malloc(128);
                    memset(src, 0, 0x80u);
                    if ( try_match(dest, src) )
                    {
                      v43 = sprintf(v100, "PATTERN MATCHED : %s\n", src);
                    }
                    else
                    {
                      v42 = strcpy(v100, "NO PATTERN MATCHED\n");
                    }
                    v117 = send(v98, v100, strlen(v100), 0);
                    if ( v117 < 0 )
                      perror("send() failed");
                    free(src);
                    free(v100);
                    close(v98);
                    exit(0);
                  }
                }
                else
                {
                  v36 = "Invalid DNA string, must contain character only from [ATGC] alphabet and have non-zero length\n";
                  v117 = send(v98, v36, strlen(v36), 0);
                  if ( v117 < 0 )
                  {
                    perror("send() failed");
                    v112 = 1;
                    goto LABEL_81;
                  }
                }
                memset(dest, 0, 0x80u);
                v107[i] = 0;
              }
              else if ( strnlen(dest, 128) == 128 )
              {
                buf = "Invalid request, must be a '\\n'-terminated line no longer than 64 chars\n";
                memset(dest, 0, 0x80u);
                v107[i] = 0;
                v117 = send(v98, buf, strlen(buf), 0);
                if ( v117 < 0 )
                {
                  perror("send() failed");
                  v112 = 1;
                  goto LABEL_81;
                }
              }
            }
            if ( errno != EAGAIN )
            {
              perror("recv() failed");
              v112 = 1;
            }
          }
        }
LABEL_81:
        if ( v112 )
        {
          close(v98);
          fds[i].fd = -1;
          v107[i] = 0;
          v106[i] = 0;
          v15 = &v108[128 * i];
          memset(v15, 0, 0x80u);
          v113 = 1;
        }
        ++i;
      }
      if ( v113 )
      {
        v113 = 0;
        for ( i = 0; i < (signed int)nfds; ++i )
        {
          if ( fds[i].fd == -1 )
          {
            for ( j = i; j < (signed int)nfds; ++j )
              fds[j].fd = fds[j+1].fd;
            --i;
            --nfds;
          }
        }
      }
    }
  }
  while ( errno == EINTR );
  perror("poll() failed");
}

//----- (0804AB60) --------------------------------------------------------
void handle_sigchld()
{
  __pid_t result; // eax@1

  do
    result = waitpid(-1, 0, 1);
  while ( result > 0 );
}

//----- (0804ABC0) --------------------------------------------------------
int main(int argc, const char **argv, const char **envp)
{
  int port; // [sp+44h] [bp-18h]@1
  int v13; // [sp+50h] [bp-Ch]@1

  v13 = 0;
  port = 1013;
  if ( argc <= 1 || (port = atoi(argv[1]), port > 0) && port <= 0xFFFF )
  {
    signal(SIGCHLD, handle_sigchld);
    run(port);
    v13 = 0;
  }
  else
  {
    fprintf(stderr, "Invalid listen_port '%s'\n", argv[1]);
    v13 = -1;
  }
  return v13;
}

