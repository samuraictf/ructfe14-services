/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2014 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/socket.h>
#include <stdint.h>
#include <signal.h>
#include <errno.h>
#include <netinet/in.h>
#include <poll.h>
#include <fcntl.h>

//-------------------------------------------------------------------------
// Data declarations

FILE *file; // idb
char  **root; // idb

//----- (08048EF0) --------------------------------------------------------
void make_non_blocking(int a1)
{
  int v1; // eax@1
  int result; // eax@1

  v1 = fcntl(a1, F_GETFL);
  result = fcntl(a1, F_SETFL, v1 | O_NONBLOCK);
  if ( result < 0 )
  {
    perror("fcntl() on set O_NONBLOCK failed");
    exit(-1);
  }
}

//----- (08049030) --------------------------------------------------------
int check_alphabet(const char *a1)
{
  size_t i; // [sp+4h] [bp-10h]@3
  size_t v3; // [sp+8h] [bp-Ch]@1
  signed int v4; // [sp+10h] [bp-4h]@2

  v3 = strlen(a1);
  if ( v3 )
  {
    for ( i = 0; i < v3; ++i )
    {
      if ( a1[i] != 'A' && a1[i] != 'T' && a1[i] != 'G' && a1[i] != 'C' )
        return 0;
    }
    v4 = 1;
  }
  else
  {
    v4 = 0;
  }
  return v4;
}

//----- (08049110) --------------------------------------------------------
int try_match_rec(char **a1, char * a2, signed int a3, char *a4)
{
  int v4; // eax@9
  int v5; // eax@18
  int v6; // eax@27
  int v7; // eax@36
  int v9; // [sp+13h] [bp-51h]@42
  char * v10; // [sp+18h] [bp-4Ch]@35
  char ** v11; // [sp+1Ch] [bp-48h]@35
  char * v12; // [sp+24h] [bp-40h]@26
  char** v13; // [sp+28h] [bp-3Ch]@26
  char * v14; // [sp+30h] [bp-34h]@17
  char **v15; // [sp+34h] [bp-30h]@17
  char *src; // [sp+3Ch] [bp-28h]@8
  char **dest; // [sp+40h] [bp-24h]@8
  int v18; // [sp+58h] [bp-Ch]@2

  if ( a3 <= 2 )
  {
    if ( *a2 || !a1[4] )
    {
      if ( a1[0] )
      {
        *a4 = 'A';
        if ( *a2 )
        {
          dest = (char**)a1[0];
          src = a2 + 1;
          v4 = *a2 == 'A' ? try_match_rec(dest, src, a3, a4 + 1) : try_match_rec(dest, src, a3 + 1, a4 + 1);
          if ( v4 )
            return 1;
        }
        if ( try_match_rec((char**)a1[0], a2, a3 + 1, a4 + 1) )
          return 1;
      }
      if ( a1[1] )
      {
        *a4 = 'T';
        if ( *a2 )
        {
          v15 = (char**)a1[1];
          v14 = a2 + 1;
          v5 = *a2 == 'T' ? try_match_rec(v15, v14, a3, a4 + 1) : try_match_rec(v15, v14, a3 + 1, a4 + 1);
          if ( v5 )
            return 1;
        }
        if ( try_match_rec((char**)a1[1], a2, a3 + 1, a4 + 1) )
          return 1;
      }
      if ( a1[2] )
      {
        *a4 = 'G';
        if ( *a2 )
        {
          v13 = (char**)a1[2];
          v12 = a2 + 1;
          v6 = *a2 == 'G' ? try_match_rec(v13, v12, a3, a4 + 1) : try_match_rec(v13, v12, a3 + 1, a4 + 1);
          if ( v6 )
            return 1;
        }
        if ( try_match_rec((char**)a1[2], a2, a3 + 1, a4 + 1) )
          return 1;
      }
      if ( a1[3] )
      {
        *a4 = 'C';
        if ( *a2 )
        {
          v11 = (char**)a1[3];
          v10 = a2 + 1;
          v7 = *a2 == 'C' ? try_match_rec(v11, v10, a3, a4 + 1) : try_match_rec(v11, v10, a3 + 1, a4 + 1);
          if ( v7 )
            return 1;
        }
        if ( try_match_rec((char**)a1[3], a2, a3 + 1, a4 + 1) )
          return 1;
      }
      *a4 = 0;
      v9 = 0;
      if ( *a2 )
        v9 = try_match_rec(a1, a2 + 1, a3 + 1, a4) != 0;
      v18 = v9;
    }
    else
    {
      *a4 = ' ';
      v18 = 1;
      strcpy(a4 + 1, a1[4]);
    }
  }
  else
  {
    v18 = 0;
  }
  return v18;
}

//----- (080495B0) --------------------------------------------------------
int try_match(char * a1, char * a2)
{
  return try_match_rec(root, a1, 0, a2);
}

//----- (08049600) --------------------------------------------------------
char *try_add_pattern(char *pattern, char *a2)
{
  size_t i; // [sp+44h] [bp-20h]@1
  char **v4; // [sp+48h] [bp-1Ch]@1
  size_t v5; // [sp+4Ch] [bp-18h]@1
  size_t patlen; // [sp+50h] [bp-14h]@1
  char *result; // [sp+5Ch] [bp-8h]@20

  patlen = strlen(pattern);
  v5 = strlen(a2);
  v4 = root;
  for ( i = 0; i < patlen; ++i )
  {
    switch ( pattern[i] )
    {
      case 'A':
        if ( !v4[0] )
        {
          v4[0] = malloc(20);
          memset(v4[0], 0, 0x14u);
        }
        v4 = (char**)v4[0];
        break;
      case 'T':
        if ( !v4[1] )
        {
          v4[1] = malloc(20);
          memset(v4[1], 0, 0x14u);
        }
        v4 = (char**)v4[1];
        break;
      case 'G':
        if ( !v4[2] )
        {
          v4[2] = malloc(20);
          memset(v4[2], 0, 0x14u);
        }
        v4 = (char**)v4[2];
        break;
      default:
        if ( !v4[3] )
        {
          v4[3] = malloc(20);
          memset(v4[3], 0, 0x14u);
        }
        v4 = (char**)v4[3];
        break;
    }
  }
  if ( v4[4] )
  {
    result = v4[4];
  }
  else
  {
    v4[4] = malloc(v5 + 1);
    memset(v4[4], 0, v5 + 1);
    result = a2;
    strcpy(v4[4], a2);
  }
  return result;
}

//----- (080498C0) --------------------------------------------------------
int init_state(FILE *a1)
{
  char *space; // [sp+24h] [bp-18h]@4
  int lines; // [sp+28h] [bp-14h]@1
  size_t index; // [sp+30h] [bp-Ch]@1
  char *linebuf; // [sp+34h] [bp-8h]@1

  linebuf = malloc(128);
  index = 0;
  lines = 0;
  while ( fread(index + linebuf, 1u, 1u, a1) > 0 )
  {
    if ( linebuf[index] == '\n' )
    {
      linebuf[index] = 0;
      space = memchr(linebuf, ' ', index);
      if ( !space )
      {
        fprintf(stderr, "Corrupted state!");
        exit(-1);
      }
      *space = 0;
      index = 0;
      ++lines;
      try_add_pattern(linebuf, space + 1);
    }
    else
    {
      ++index;
    }
  }
  return lines;
}

//----- (08049A00) --------------------------------------------------------
void  run(int port)
{
  int v2; // eax@4
  int v4; // ecx@4
  int v6; // edx@37
  char *v7; // esi@39
  size_t v8; // ecx@39
  char *v15; // [sp+0h] [bp-24254h]@82
  const char *v25; // [sp+30h] [bp-24224h]@77
  const char *v36; // [sp+5Ch] [bp-241F8h]@68
  void *buf; // [sp+98h] [bp-241BCh]@48
  const char *found_pat; // [sp+138h] [bp-2411Ch]@72
  char *src; // [sp+13Ch] [bp-24118h]@60
  int cpid; // [sp+140h] [bp-24114h]@56
  char *space_ptr; // [sp+144h] [bp-24110h]@54
  char *lf_ptr; // [sp+148h] [bp-2410Ch]@46
  socklen_t addr_len; // [sp+14Ch] [bp-24108h]@31
  struct sockaddr_in ca; // [sp+150h] [bp-24104h]@31
  int ready_fd; // [sp+160h] [bp-240F4h]@29
  unsigned int now; // [sp+164h] [bp-240F0h]@23
  char *output_buf; // [sp+168h] [bp-240ECh]@19
  int j; // [sp+16Ch] [bp-240E8h]@88
  int i; // [sp+170h] [bp-240E4h]@23
  nfds_t v103; // [sp+174h] [bp-240E0h]@1
  nfds_t nfds; // [sp+178h] [bp-240DCh]@1
  char *dest; // [sp+17Ch] [bp-240D8h]@39
  int accept_times[1025]; // [sp+180h] [bp-240D4h]@19
  int line_lengths[1025]; // [sp+1184h] [bp-230D0h]@19
  char client_bufs[131200]; // [sp+2188h] [bp-220CCh]@19
  struct pollfd fds[1025]; // [sp+22208h] [bp-204Ch]@19
  struct sockaddr_in addr; // [sp+24210h] [bp-44h]@13
  int do_kill_conn; // [sp+24224h] [bp-30h]@25
  int v113; // [sp+24228h] [bp-2Ch]@1
  int client; // [sp+2422Ch] [bp-28h]@1
  int server_sock; // [sp+24230h] [bp-24h]@1
  int optval; // [sp+24234h] [bp-20h]@1
  int v117; // [sp+24238h] [bp-1Ch]@10
  size_t size; // [sp+2423Ch] [bp-18h]@51

  optval = 1;
  server_sock = -1;
  client = -1;
  v113 = 0;
  nfds = 1;
  v103 = 0;
  root = (char **)malloc(20);
  memset(root, 0, 0x14u);
  file = fopen("state", "a+");
  if ( !file )
  {
    perror("can't open state file for writing");
    exit(-1);
  }
  fseek(file, SEEK_SET, 0);
  v2 = init_state(file);
  printf("Loaded %d lines from state file\n", v2);
  make_non_blocking(fileno(file));
  setvbuf(file, 0, 2, 0);
  server_sock = socket(AF_INET, SOCK_STREAM, 0);
  if ( server_sock < 0 )
  {
    perror("socket() failed");
    exit(-1);
  }
  if ( setsockopt(server_sock, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)) < 0 )
  {
    perror("setsockopt() failed");
    exit(-1);
  }
  make_non_blocking(server_sock);
  memset(&addr, 0, sizeof(addr));
  addr.sin_family = AF_INET;
  addr.sin_port = htons(port);
  if ( bind(server_sock, (struct sockaddr*)&addr, sizeof(addr)) < 0 )
  {
    perror("bind() failed");
    exit(-1);
  }
  if ( listen(server_sock, 1024) < 0 )
  {
    perror("listen() failed");
    exit(-1);
  }
  memset(fds, 0, sizeof(fds));
  fds[0].fd = server_sock;
  fds[0].events = POLLIN;
  memset(client_bufs, 0, 0x20080u);
  memset(line_lengths, 0, 0x1004u);
  memset(accept_times, 0, 0x1004u);
  output_buf = (char *)malloc(128);
  do
  {
    while ( 1 )
    {
      if ( poll(fds, nfds, -1) < 0 )
        break;
      now = time(NULL);
      v103 = nfds;
      i = 0;
      //sample each active fd
      while ( i < (signed int)v103 )
      {
        do_kill_conn = 0;
        if ( fds[i].fd != server_sock && accept_times[i] && accept_times[i] + 30 < now )
          do_kill_conn = 1;
        ready_fd = fds[i].fd;
        if ( fds[i].revents )
        {
          if ( ready_fd == server_sock )
          {
            //ready to accept new client
            while ( 1 )
            {
              addr_len = sizeof(ca);
              client = accept(server_sock, (struct sockaddr*)&ca, &addr_len);
              if ( client < 0 )
                break;
              make_non_blocking(client);
              fds[nfds].fd = client;
              fds[nfds].events = POLLIN;
              accept_times[nfds++] = time(NULL);
              if ( client == -1 )
                goto LABEL_81;
            }
            if ( errno != EAGAIN)
            {
              perror("accept() failed");
              exit(-1);
            }
          }
          else
          {
            while ( 1 )
            {
              dest = &client_bufs[128 * i];
              v7 = &dest[line_lengths[i]];
              v8 = 128 - line_lengths[i];
              v117 = recv(ready_fd, v7, v8, 0);
              if ( v117 < 0 )
                break;
              if ( !v117 )
              {
                do_kill_conn = 1;
                goto LABEL_81;
              }
              line_lengths[i] += v117;
              lf_ptr = (char*)memchr(dest, '\n', line_lengths[i]);
              if ( lf_ptr )
              {
                size = lf_ptr - dest;
                if ( size > 0 && dest[size - 1] == '\r' )
                  --size;
                dest[size] = 0;
                space_ptr = (char *)memchr(dest, ' ', size);
                if ( space_ptr )
                {
                  *space_ptr++ = 0;
                  if ( check_alphabet(dest) )
                  {
                    found_pat = try_add_pattern(dest, space_ptr);
                    space_ptr[-1] = ' ';  //put the space back
                    if ( found_pat == space_ptr )
                    {
                      //this is a new pattern add to file
                      fwrite(dest, size, 1u, file);
                      fwrite("\n", 1u, 1u, file);
                    }
                    sprintf(output_buf, "%s\n", found_pat);
                    v117 = send(ready_fd, output_buf, strlen(output_buf), 0);
                    if ( v117 < 0 )
                    {
                      perror("send() failed");
                      do_kill_conn = 1;
                      goto LABEL_81;
                    }
                  }
                  else
                  {
                    v25 = "Invalid Virus Pattern string, must be in <DNA-sequence><space><Comment> format\n";
                    v117 = send(ready_fd, v25, strlen(v25), 0);
                    if ( v117 < 0 )
                    {
                      perror("send() failed");
                      do_kill_conn = 1;
                      goto LABEL_81;
                    }
                  }
                }
                else if ( check_alphabet(dest) )
                {
                  //good indication the vuln is in here so we don't crash server
                  //but could take over listening socket and kill parent :)
                  cpid = fork();
                  if ( cpid == -1 )
                  {
                    perror("fork()");
                    exit(-1);
                  }
                  if ( !cpid )
                  {
                    src = (char *)malloc(128);
                    memset(src, 0, 0x80u);
                    if ( try_match(dest, src) )
                    {
                     //here is the overflow ****
                     //send A *******************************...
                     //can have up to 125 *, which replace %s below to make
                     //144 char string into 128 bute buffer
                      sprintf(output_buf, "PATTERN MATCHED : %s\n", src);
                    }
                    else
                    {
                      strcpy(output_buf, "NO PATTERN MATCHED\n");
                    }
                    if ( send(ready_fd, output_buf, strlen(output_buf), 0) < 0 )
                      perror("send() failed");
                    free(src);
                    free(output_buf);
                    close(ready_fd);
                    exit(0);
                  }
                }
                else
                {
                  v36 = "Invalid DNA string, must contain character only from [ATGC] alphabet and have non-zero length\n";
                  v117 = send(ready_fd, v36, strlen(v36), 0);
                  if ( v117 < 0 )
                  {
                    perror("send() failed");
                    do_kill_conn = 1;
                    goto LABEL_81;
                  }
                }
                memset(dest, 0, 0x80u);
                line_lengths[i] = 0;
              }
//              else if ( strnlen(dest, 128) == 128 )
              else if ( strnlen(dest, 64) == 64 )  //<== *** changed to 64 here per comment below
              {
                buf = "Invalid request, must be a '\\n'-terminated line no longer than 64 chars\n";
                memset(dest, 0, 0x80u);
                line_lengths[i] = 0;
                v117 = send(ready_fd, buf, strlen(buf), 0);
                if ( v117 < 0 )
                {
                  perror("send() failed");
                  do_kill_conn = 1;
                  goto LABEL_81;
                }
              }
            }
            if ( errno != EAGAIN )
            {
              perror("recv() failed");
              do_kill_conn = 1;
            }
          }
        }
LABEL_81:
        if ( do_kill_conn )
        {
          close(ready_fd);
          fds[i].fd = -1;
          line_lengths[i] = 0;
          accept_times[i] = 0;
          v15 = &client_bufs[128 * i];
          memset(v15, 0, 0x80u);
          v113 = 1;
        }
        ++i;
      }
      if ( v113 )
      {
        v113 = 0;
        for ( i = 0; i < (signed int)nfds; ++i )
        {
          if ( fds[i].fd == -1 )
          {
            for ( j = i; j < (signed int)nfds; ++j )
              fds[j].fd = fds[j+1].fd;
            --i;
            --nfds;
          }
        }
      }
    }
  }
  while ( errno == EINTR );
  perror("poll() failed");
}

//----- (0804AB60) --------------------------------------------------------
void handle_sigchld()
{
  __pid_t result; // eax@1

  do
    result = waitpid(-1, 0, 1);
  while ( result > 0 );
}

//----- (0804ABC0) --------------------------------------------------------
int main(int argc, const char **argv, const char **envp)
{
  int port; // [sp+44h] [bp-18h]@1
  int v13; // [sp+50h] [bp-Ch]@1

  v13 = 0;
  port = 1013;
  if ( argc <= 1 || (port = atoi(argv[1]), port > 0) && port <= 0xFFFF )
  {
    signal(SIGCHLD, handle_sigchld);
    run(port);
    v13 = 0;
  }
  else
  {
    fprintf(stderr, "Invalid listen_port '%s'\n", argv[1]);
    v13 = -1;
  }
  return v13;
}

